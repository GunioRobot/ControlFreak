#!/usr/bin/perl
use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;
use Carp;
use IO::Socket::INET;
use IO::Socket::UNIX;
use Socket qw(SOCK_STREAM);

my %options = ( address => "tcp://127.0.0.1:11311" );

GetOptions(
    'y|yes'      => \$options{yes},
    'address=s'  => \$options{address},

    'h|help'     => \$options{help},
    'm|man'      => \$options{man},
) or pod2usage(2);

pod2usage(1)             if $options{help};
pod2usage(-verbose => 2) if $options{man};

my $command = shift;

my $socket = get_sock_from_addr($options{address})
    or croak "Cannot get a socket for '$options{address}'";

my $cmd = "cmd_$command";

my $commander = ControlFreak::Commander->new( $socket );

if (my $coderef = $commander->can($cmd)) {
    $coderef->($commander, @ARGV);
}
else {
    croak "Sorry unknown command $command";
}

$commander->exit;

## I'm pretty sure this doesn't work in AF_INET6
sub get_sock_from_addr {
    my $address = shift;
    if ($address =~ m!^tcp://(.+)!) {
        my $peer = $1;
        $peer =~ s{/+$}{};
        my $sock = IO::Socket::INET->new(
            PeerAddr => $peer,
            Proto    => 'tcp',
        );
        return unless $sock;
        $sock->autoflush(1);
        return $sock;
    }
    elsif ($address =~ m!^unix://(.+)!) {
        return IO::Socket::UNIX->new(
            Type => SOCK_STREAM,
            Peer => "/$1",
        );
    }
    else {
        return;
    }
}

package ControlFreak::Commander;
use strict;
use warnings;
use Socket qw($CRLF);
use Carp;

sub new { bless { 'socket' => $_[1] }, $_[0] };

sub send_request {
    my $commander = shift;
    my $request = shift;
    my $socket = $commander->{socket};
    $socket->print("$request$CRLF");
}

sub cmd_list {
    my $commander = shift;
    $commander->send_request("command list");
    my ($error, $response) = $commander->read_response;
    croak "error: $error" if $error;
    for (@$response) {
        print "$_\n";
    }
}

sub cmd_status {
    my $commander = shift;
    my @args      = parse_svcs(@_);

    my %statuses;
    @args = ('all') unless @args;
    for (@args) {
        $commander->send_request("command status $_");
        my ($error, $response) = $commander->read_response;
        if ($error) {
            warn "error: $error";
            next;
        }
        $commander->parse_statuses($response, \%statuses);
    }
    for my $svcname (keys %statuses) {
        print "$svcname $statuses{$svcname}\n"
    }
}

sub parse_statuses {
    my $commander = shift;
    my ($response, $statuses) = @_;

    for (@$response) {
       my ($svcname, $rest) = split /\s/, $_, 2;
       next if defined $statuses->{$svcname};
       $statuses->{$svcname} = $rest;
    }
}

sub cmd_desc {
    my $commander = shift;
    $commander->send_request("command desc");
    my ($error, $response) = $commander->read_response;
    croak "error: $error" if $error;
    for (@$response) {
        print "$_\n";
    }
}

sub cmd_up      { _cmd_svc( "up",      @_ ) }
sub cmd_down    { _cmd_svc( "down",    @_ ) }
sub cmd_stop    { _cmd_svc( "stop",    @_ ) }
sub cmd_start   { _cmd_svc( "start",   @_ ) }
sub cmd_restart { _cmd_svc( "restart", @_ ) }

sub _cmd_svc {
    my $command   = shift;
    my $commander = shift;
    my @svcrefs   = @_;

    my @arguments = parse_svcs(@svcrefs);
    for (@arguments) {
        $commander->send_request("command $command $_");
        my ($error) = $commander->read_response;
        if ($error) {
            croak "error: $error";
        }
    }
}

sub read_response {
    my $commander = shift;
    my $socket = $commander->{socket};
    my @response;
    my $error;
    while (<$socket>) {
        last unless defined;
        last if /^OK$CRLF/;
        if (/^ERROR: (.*)$CRLF/) {
            $error = $1;
            last;
        }
        chomp;
        push @response, $_;
    }
    return ($error, \@response);
}

sub parse_svcs {
    my @args = @_;

    my @parsed;

    for (@args) {
        if ($_ eq 'all') {
            return ('all');
        }
        if (/^@(.*)$/) {
            push @parsed, "tag $1";
        }
        else {
            push @parsed, "service $_";
        }
    }
    return @parsed;
}

sub exit {
    my $commander = shift;
    $commander->send_request("exit");
    $commander->{socket}->close;
}

__END__

=head1 NAME

cfkctl - control ControlFreak!

=head1 SYNOPSIS

cfkctl [options] command [svcref ...]

 Options:
    -y, --yes           Run non-interactively without asking for confirmations
    -h, --help          Help
    -m, --man           More help
    --address=SOCK      Unix or tcp socket to connect to ControlFreak
                        [defaults to 127.0.0.1:11311]

 Commands:
    up                  Make sure service is up
    down                Make sure service is down
    restart             If service is up, restart it
    destroy             Down a service and deletes it
    list                List all services
    status              Print statuses of services

 Services references:
    all                 All known services [default]
    svcname             A string of the name of the service
    @tag                All services tagged with the tag C<tag>

  List of statuses:
    up
    down
    failed   included in C<down>
    backoff  included in C<down>
    stopped  included in C<down>


=head1 OPTIONS

Please see L<SYNOPSIS>.

=head1 DESCRIPTION

B<cfkctl> is B<ControlFreak> command line interface, it connects to
the management port and issues commands to it.

This script is intended to manage one instance of B<ControlFreak> running
one one server.

=head1 EXAMPLES

    ## stop everything that is not already stopped
    cfkctl down all

    ## make sure all webs are up (FastCGI processes for instance)
    cfkctl up @webs

    ## list all services
    cfkctl list

    ## status of some services
    cfkctl status
    cfkctl status @webs
    cfkctl status s1

    ## remove a service reference completely
    cfkctl destroy syncer
